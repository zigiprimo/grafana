{"version":3,"file":"704.js","mappings":"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","sources":["webpack://@grafana-plugins/tempo/../../../../../node_modules/@grafana/monaco-logql/index.js","webpack://@grafana-plugins/tempo/../../../../../node_modules/react-use/esm/useLatest.js","webpack://@grafana-plugins/tempo/../../../../../node_modules/@grafana/lezer-logql/index.es.js"],"sourcesContent":["\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.monarchlanguage = exports.languageConfiguration = void 0;\nexports.languageConfiguration = {\n    // the default separators except `@$`\n    wordPattern: /(-?\\d*\\.\\d\\w*)|([^`~!#%^&*()\\-=+\\[{\\]}\\\\|;:'\",.<>\\/?\\s]+)/g,\n    comments: {\n        lineComment: \"#\",\n    },\n    brackets: [\n        [\"{\", \"}\"],\n        [\"[\", \"]\"],\n        [\"(\", \")\"],\n    ],\n    autoClosingPairs: [\n        { open: \"{\", close: \"}\" },\n        { open: \"[\", close: \"]\" },\n        { open: \"(\", close: \")\" },\n        { open: '\"', close: '\"' },\n        { open: \"'\", close: \"'\" },\n        { open: \"`\", close: \"`\" },\n    ],\n    surroundingPairs: [\n        { open: \"{\", close: \"}\" },\n        { open: \"[\", close: \"]\" },\n        { open: \"(\", close: \")\" },\n        { open: '\"', close: '\"' },\n        { open: \"'\", close: \"'\" },\n        { open: \"`\", close: \"`\" },\n        { open: \"<\", close: \">\" },\n    ],\n    folding: {},\n};\n// LogQL built-in aggregation operators\n// https://grafana.com/docs/loki/latest/logql/metric_queries/#built-in-aggregation-operators\nvar aggregations = [\n    \"sum\",\n    \"avg\",\n    \"min\",\n    \"max\",\n    \"stddev\",\n    \"stdvar\",\n    \"count\",\n    \"topk\",\n    \"bottomk\",\n];\n// LogQL parser expressions\n// https://grafana.com/docs/loki/latest/logql/log_queries/#parser-expression\nvar parsers = [\"json\", \"logfmt\", \"regexp\", \"unpack\", \"pattern\"];\n// LogQL format expressions\n// https://grafana.com/docs/loki/latest/logql/log_queries/#parser-expression\nvar format_expressions = [\"line_format\", \"label_format\"];\n// LogQL vector aggregations\n// https://grafana.com/docs/loki/latest/logql/metric_queries/#range-vector-aggregation\nvar vector_aggregations = [\n    \"count_over_time\",\n    \"rate\",\n    \"bytes_over_time\",\n    \"bytes_rate\",\n    \"avg_over_time\",\n    \"sum_over_time\",\n    \"min_over_time\",\n    \"max_over_time\",\n    \"stdvar_over_time\",\n    \"stddev_over_time\",\n    \"quantile_over_time\",\n    \"first_over_time\",\n    \"last_over_time\",\n    \"absent_over_time\",\n];\n// LogQL by and without clauses\nvar vector_matching = [\"by\", \"without\"];\n// Produce a regex matching elements : (by|without)\nvar vectorMatchingRegex = \"(\".concat(vector_matching.reduce(function (prev, curr) { return \"\".concat(prev, \"|\").concat(curr); }), \")\");\n// LogQL Operators\nvar operators = [\n    \"+\",\n    \"-\",\n    \"*\",\n    \"/\",\n    \"%\",\n    \"^\",\n    \"==\",\n    \"!=\",\n    \">\",\n    \"<\",\n    \">=\",\n    \"<=\",\n    \"|=\",\n    \"!=\",\n    \"|~\",\n    \"!~\",\n    \"and\",\n    \"or\",\n    \"unless\",\n    \"|\",\n];\n// Merging all the keywords in one list\nvar keywords = aggregations\n    .concat(parsers)\n    .concat(format_expressions)\n    .concat(vector_aggregations)\n    .concat(vector_matching);\nexports.monarchlanguage = {\n    ignoreCase: false,\n    defaultToken: \"\",\n    tokenPostfix: \".logql\",\n    keywords: keywords,\n    operators: operators,\n    vectorMatching: vectorMatchingRegex,\n    // we include these common regular expressions\n    symbols: /[=><!~?:&|+\\-*\\/^%]+/,\n    escapes: /\\\\(?:[abfnrtv\\\\\"']|x[0-9A-Fa-f]{1,4}|u[0-9A-Fa-f]{4}|U[0-9A-Fa-f]{8})/,\n    digits: /\\d+(_+\\d+)*/,\n    octaldigits: /[0-7]+(_+[0-7]+)*/,\n    binarydigits: /[0-1]+(_+[0-1]+)*/,\n    hexdigits: /[[0-9a-fA-F]+(_+[0-9a-fA-F]+)*/,\n    integersuffix: /(ll|LL|u|U|l|L)?(ll|LL|u|U|l|L)?/,\n    floatsuffix: /[fFlL]?/,\n    // The main tokenizer for our languages\n    tokenizer: {\n        root: [\n            // 'by', 'without' and vector matching\n            [/@vectorMatching\\s*(?=\\()/, \"type\", \"@clauses\"],\n            // labels\n            [/[a-z_]\\w*(?=\\s*(=|!=|=~|!~))/, \"tag\"],\n            // comments\n            [/(^#.*$)/, \"comment\"],\n            // all keywords have the same color\n            [\n                /[a-zA-Z_]\\w*/,\n                {\n                    cases: {\n                        \"@keywords\": \"type\",\n                        \"@default\": \"identifier\",\n                    },\n                },\n            ],\n            // strings\n            [/\"/, \"string\", \"@string_double\"],\n            [/'/, \"string\", \"@string_single\"],\n            [/`/, \"string\", \"@string_backtick\"],\n            // whitespace\n            { include: \"@whitespace\" },\n            // delimiters and operators\n            [/[{}()\\[\\]]/, \"@brackets\"],\n            [/[<>](?!@symbols)/, \"@brackets\"],\n            [\n                /@symbols/,\n                {\n                    cases: {\n                        \"@operators\": \"delimiter\",\n                        \"@default\": \"\",\n                    },\n                },\n            ],\n            // numbers\n            [/\\d+(?:ms|[smhdwy])/, \"number\"],\n            [/\\d*\\d+[eE]([\\-+]?\\d+)?(@floatsuffix)/, \"number.float\"],\n            [/\\d*\\.\\d+([eE][\\-+]?\\d+)?(@floatsuffix)/, \"number.float\"],\n            [/0[xX][0-9a-fA-F']*[0-9a-fA-F](@integersuffix)/, \"number.hex\"],\n            [/0[0-7']*[0-7](@integersuffix)/, \"number.octal\"],\n            [/0[bB][0-1']*[0-1](@integersuffix)/, \"number.binary\"],\n            [/\\d[\\d']*\\d(@integersuffix)/, \"number\"],\n            [/\\d(@integersuffix)/, \"number\"],\n        ],\n        string_double: [\n            // Set to token: number to differentiate color\n            [/\\{\\{(.*?)\\}\\}/, { token: 'number' }],\n            [/[^\\\\\"]/, \"string\"],\n            [/@escapes/, \"string.escape\"],\n            [/\\\\./, \"string.escape.invalid\"],\n            [/\"/, \"string\", \"@pop\"],\n        ],\n        string_single: [\n            [/[^\\\\']+/, \"string\"],\n            [/@escapes/, \"string.escape\"],\n            [/\\\\./, \"string.escape.invalid\"],\n            [/'/, \"string\", \"@pop\"],\n        ],\n        string_backtick: [\n            // Set to token: number to differentiate color\n            [/\\{\\{(.*?)\\}\\}/, { token: 'number' }],\n            [/[^\\\\`]/, \"string\"],\n            [/@escapes/, \"string.escape\"],\n            [/\\\\./, \"string.escape.invalid\"],\n            [/`/, \"string\", \"@pop\"],\n        ],\n        clauses: [\n            [/[^(,)]/, \"tag\"],\n            [/\\)/, \"identifier\", \"@pop\"],\n        ],\n        whitespace: [[/[ \\t\\r\\n]+/, \"white\"]],\n    },\n};\n","import { useRef } from 'react';\nvar useLatest = function (value) {\n    var ref = useRef(value);\n    ref.current = value;\n    return ref;\n};\nexport default useLatest;\n","import { LRParser } from '@lezer/lr';\n\n// This file was generated by lezer-generator. You probably shouldn't edit it.\nconst Json$1 = 1,\n  Logfmt$1 = 2,\n  Unpack$1 = 3,\n  Pattern$1 = 4,\n  Regexp$1 = 5,\n  Unwrap$1 = 6,\n  Ip$1 = 7,\n  LabelFormat$1 = 8,\n  LineFormat$1 = 9,\n  LabelReplace$1 = 10,\n  Vector$1 = 11,\n  Offset$1 = 12,\n  Bool$1 = 13,\n  On$1 = 14,\n  Ignoring$1 = 15,\n  GroupLeft$1 = 16,\n  GroupRight$1 = 17,\n  Decolorize$1 = 18,\n  Drop$1 = 19,\n  Keep$1 = 20,\n  By$1 = 21,\n  Without$1 = 22,\n  And$1 = 23,\n  Or$1 = 24,\n  Unless$1 = 25,\n  Sum$1 = 26,\n  Avg$1 = 27,\n  Count$1 = 28,\n  Max$1 = 29,\n  Min$1 = 30,\n  Stddev$1 = 31,\n  Stdvar$1 = 32,\n  Bottomk$1 = 33,\n  Topk$1 = 34,\n  Sort$1 = 35,\n  Sort_Desc$1 = 36,\n  MetricExpr$1 = 93;\n\nconst keywordTokens = {\n  json: Json$1,\n  logfmt: Logfmt$1,\n  unpack: Unpack$1,\n  pattern: Pattern$1,\n  regexp: Regexp$1,\n  ip: Ip$1,\n  label_format: LabelFormat$1,\n  line_format: LineFormat$1,\n  label_replace: LabelReplace$1,\n  vector: Vector$1,\n  offset: Offset$1,\n  bool: Bool$1,\n  on: On$1,\n  ignoring: Ignoring$1,\n  group_left: GroupLeft$1,\n  group_right: GroupRight$1,\n  unwrap: Unwrap$1,\n  decolorize: Decolorize$1,\n  drop: Drop$1,\n  keep: Keep$1,\n};\n\nconst specializeIdentifier = (value) => {\n  return keywordTokens[value.toLowerCase()] || -1;\n};\n\nconst contextualKeywordTokens = {\n  by: By$1,\n  without: Without$1,\n  and: And$1,\n  or: Or$1,\n  unless: Unless$1,\n  sum: Sum$1,\n  avg: Avg$1,\n  count: Count$1,\n  max: Max$1,\n  min: Min$1,\n  stddev: Stddev$1,\n  stdvar: Stdvar$1,\n  bottomk: Bottomk$1,\n  topk: Topk$1,\n  sort: Sort$1,\n  sort_desc: Sort_Desc$1,\n};\n\nconst extendIdentifier = (value) => {\n  return contextualKeywordTokens[value.toLowerCase()] || -1;\n};\n\n// This file was generated by lezer-generator. You probably shouldn't edit it.\nconst spec_Identifier = {__proto__:null,count_over_time:295, rate:297, rate_counter:299, bytes_over_time:301, bytes_rate:303, avg_over_time:305, sum_over_time:307, min_over_time:309, max_over_time:311, stddev_over_time:313, stdvar_over_time:315, quantile_over_time:317, first_over_time:319, last_over_time:321, absent_over_time:323, bytes:329, duration:331, duration_seconds:333};\nconst parser = LRParser.deserialize({\n  version: 14,\n  states: \"EnOYQPOOO#cQPO'#DVO$rQPO'#DUOYQPO'#DUOOQO'#E_'#E_O%PQPO'#E^OOQO'#Ez'#EzO%UQPO'#EyQ%aQPOOOOQO'#FY'#FYO&bQPO'#FYO&gQPO'#FZO&lQPO'#F[OOQO'#E]'#E]OOQO'#DT'#DTOOQO'#E`'#E`OOQO'#Ea'#EaOOQO'#Eb'#EbOOQO'#Ec'#EcOOQO'#Ed'#EdOOQO'#Ee'#EeOOQO'#Ef'#EfOOQO'#Eg'#EgOOQO'#Eh'#EhOOQO'#Ei'#EiOOQO'#Ej'#EjOOQO'#Ek'#EkOOQO'#El'#ElOOQO'#Em'#EmOOQO'#En'#EnO&qQPO'#DXOOQO'#DW'#DWO'PQPO,59qOOQO'#Dd'#DdO'XQPO'#DcO'aQPO'#DbO(zQPO'#DaO*eQPO'#DaOOQO'#D`'#D`O,gQPO,59pO-uQPO,59pO-|QPO,5:wO.TQPO,5:xO.`QPO'#EwO0kQPO,5;eO0rQPO,5;eO0wQPO,5;gO0wQPO,5;gO0wQPO,5;gO0wQPO,5;gO0wQPO,5;gO0wQPO,5;gOOQO,5;t,5;tOYQPO,5;uO3ZQPO,5;vO3`QPO,59sO#cQPO,59rOOQO1G/]1G/]OOQO'#Dg'#DgO3eQPO,59}O5OQPO,59}O5TQPO,59|OOQO,59|,59|O5]QPO'#DXO5zQPO'#DjO7kQPO'#DmO9XQPO'#DmOOQO'#Dm'#DmOOQO'#Dt'#DtOOQO'#Dr'#DrO+TQPO'#DrO9^QPO,59{O:wQPO'#EQO:|QPO'#EROOQO'#EU'#EUO;RQPO'#EVO;WQPO'#EYOOQO,59{,59{OOQO,59z,59zOOQO1G/[1G/[OOQO1G0c1G0cO;]QPO'#EoO.WQPO'#EoO;qQPO1G0dO;vQPO1G0dO;{QPO,5;cO<TQPO1G1PO=`QPO1G1PO=gQPO1G1PO=nQPO'#E}O?|QPO'#E|O@WQPO'#E|OYQPO1G1ROYQPO1G1ROYQPO1G1ROYQPO1G1ROYQPO1G1ROYQPO1G1RO@bQPO1G1aO@iQPO1G1bOOQO1G/_1G/_OOQO1G/^1G/^O5TQPO1G/iO@nQPO1G/iO@sQPO'#DhOB^QPO'#DhOOQO1G/h1G/hOBcQPO,59sOBiQPO,5:aOOQO'#Dk'#DkOBtQPO,5:UODeQPO'#DpOOQO'#Do'#DoOFRQPO,5:]OGlQPO,5:YOOQO,5:X,5:XOIVQPO,5:^O+TQPO,5:^O+TQPO,5:^OOQO,5:l,5:lOIeQPO'#ETOOQO'#ES'#ESOIjQPO,5:mOKTQPO'#EXOOQO'#EX'#EXOOQO'#EW'#EWOLtQPO,5:qON_QPO'#E[OOQO'#E['#E[OOQO'#EZ'#EZO!!OQPO,5:tO!#iQPO'#DaO;]QPO,5;ZO!#pQPO'#EpO!#uQPO,5;ZO!$`QPO,5;ZO!$jQPO,5;ZO!$qQPO,5;ZO!$vQPO7+&OO.WQPO7+&OOOQO'#Ex'#ExO!&WQPO1G0}OOQO1G0}1G0}O!&`QPO7+&kOYQPO7+&kO!'pQPO7+&kO!'wQPO7+&kO!(OQQO'#FOOOQO,5;i,5;iO!*^QPO,5;hO!*eQPO,5;hO!+vQPO7+&mO!+}QPO7+&mOOQO7+&m7+&mO!,[QPO7+&mO!,cQPO7+&mO!-hQPO7+&mO!-xQPO7+&{OOQO7+&|7+&|OOQO7+%T7+%TO!-}QPO7+%TO5TQPO,5:SO!.SQPO,5:SO!.XQPO1G/yOOQO1G/{1G/{OOQO1G0S1G0SOOQO1G0U1G0UOOQO,5:V,5:VO!.^QPO1G/wO!/wQPO,5:[O!/|QPO,5:ZOOQO1G/x1G/xO!0RQPO1G/xO!1lQPO,5:oO:|QPO,5:nO;RQPO,5:rO;WQPO,5:uO!1tQPO,5;^O!#uQPO1G0uO!2SQPO1G0uO!2[QPO,5;[O+TQPO,5;^O!2aQPO1G0uO!2hQPO'#EqO!2mQPO1G0uO!2aQPO1G0uO!2uQPO1G0uO!2|QPO1G0uO;lQPO1G0uOOQO1G0u1G0uOOQO<<Ij<<IjO!3XQPO<<IjO!3^QPO,5;dOOQO7+&i7+&iOOQO<<JV<<JVO!3cQPO<<JVOYQPO<<JVOOQO'#FQ'#FQO!3jQPO,5;jOOQO'#FP'#FPOOQO,5;j,5;jOOQO1G1S1G1SO!3rQPO1G1SO!5{QPO<<JgOOQO<<Ho<<HoOOQO1G/n1G/nO!6QQPO1G/nO!6VQPO7+%eOOQO1G/v1G/vOOQO1G/u1G/uOOQO1G0Z1G0ZOOQO1G0Y1G0YOOQO1G0^1G0^OOQO1G0a1G0aOOQO'#Es'#EsOOQO1G0x1G0xO!6[QPO1G0xOOQO'#Et'#EtOOQO'#Eu'#EuOOQO'#Ev'#EvOOQO7+&a7+&aOOQO1G0v1G0vO!6aQPO1G0xO!6uQPO7+&aOOQO,5;],5;]O!6}QPO7+&aO;lQPO7+&aO!7UQPO7+&aO!7aQPOAN?UOOQO1G1O1G1OO!8qQPOAN?qO!:RQPOAN?qO!:YQQO1G1UOOQO1G1U1G1UOOQO7+&n7+&nO!:bQPOAN@ROOQO7+%Y7+%YO!:gQPO<<IPO!:lQPO7+&dO!:qQPO<<I{O!:yQPO<<I{O!;RQPO'#ErO!;WQPO<<I{OOQOG24pG24pOOQOG25]G25]OOQO1G1V1G1VOOQO7+&p7+&pO!;`QPOG25mOOQOAN>kAN>kO!;eQPO<<JOOOQOAN?gAN?gO!;jQPOAN?gO!;rQPOLD+XOOQOAN?jAN?jOOQO,5:m,5:mO!;wQPO!$'NsO!;|QPO!)9D_O!<RQPO!.K9yOOQO!4//e!4//eO:|QPO'#ERO!<WQPO'#DaO!=OQPO,59pO!=YQPO'#DUOYQPO1G1ROYQPO1G1ROYQPO1G1ROYQPO1G1ROYQPO1G1ROYQPO1G1RO0wQPO,5;gO0wQPO,5;gO0wQPO,5;gO0wQPO,5;gO0wQPO,5;gO0wQPO,5;gO!>eQPO7+&mO!>lQPO7+&mO!>yQPO7+&mO!@RQPO7+&mO!@YQPO7+&mO!?QQPO'#E{\",\n  stateData: \"!@g~O$ROSuOS~OYZOZ[OjUOkUOlUOmUOnUOoUOpUOqUOrUOsUOtUO!sXO#vYO#wYO$SPO$VRO$X_O$Y`O$ZaO$[bO$]cO$^dO$_eO$`fO$agO$bhO$ciO$djO$ekO$flO$gmO~O|nO~O!PqO!RqO!XqO!YqOgxXhxXixX!jxX!lxX!mxX!nxX!oxX#vxX#wxX#xxX#yxX#zxX#{xX~O!]uO$PxX$WxX~P#hO$VzO~Oe{Of{O$V|O~Og!POh!OOi!PO!P!TO!j!TO!l!TO!m!TO!n!TO!o!TO#v!QO#w!QO#x!RO#y!RO#z!RO#{!SO~O!s!UO~O$V!VO~O$V!WO~O}!XO!P!XO!Q!XO!R!XO~O$T!YO$U!ZO~OV![O!O!]O~Oh!_Og!UXi!UX!P!UX!R!UX!X!UX!Y!UX!]!UX!j!UX!l!UX!m!UX!n!UX!o!UX#v!UX#w!UX#x!UX#y!UX#z!UX#{!UX$P!UX$W!UX$h!UX$T!UX~O!PqO!RqO!XqO!YqOg!TXh!TXi!TX!]!TX!j!TX!l!TX!m!TX!n!TX!o!TX#v!TX#w!TX#x!TX#y!TX#z!TX#{!TX$P!TX$W!TX$h!TX$T!TX~OP!cOQ!bOR!eOS!dOT!dOW!kOX!jOb!lOc!mOd!nO|!aO$V!hO~O!PqO!RqO!XqO!YqOgxahxaixa!jxa!lxa!mxa!nxa!oxa#vxa#wxa#xxa#yxa#zxa#{xa~O!]uO$Pxa$Wxa~P+]OgwXhwXiwX!PwX!jwX!lwX!mwX!nwX!owX#vwX#wwX#xwX#ywX#zwX#{wX~O$W!qO~P,tO$W!rO~P,tO!s!vO$SPO$V!tO~O$V!wO~OYZOZ[OjUOkUOlUOmUOnUOoUOpUOqUOrUOsUOtUO#vYO#wYO$SPO$VRO$X_O$Y`O$ZaO$[bO$]cO$^dO$_eO$`fO$agO$bhO$ciO$djO$ekO$flO$gmO~O!s!yO~P.eO$V!zO~O]!}O^!{O_!{OY#pPZ#pPj#pPk#pPl#pPm#pPn#pPo#pPp#pPq#pPr#pPs#pPt#pP!s#pP#v#pP#w#pP$S#pP$V#pP$X#pP$Y#pP$Z#pP$[#pP$]#pP$^#pP$_#pP$`#pP$a#pP$b#pP$c#pP$d#pP$e#pP$f#pP$g#pP~O!s#VO~O!O#WO~Oh#YOg!Vai!Va!P!Va!R!Va!X!Va!Y!Va!]!Va!j!Va!l!Va!m!Va!n!Va!o!Va#v!Va#w!Va#x!Va#y!Va#z!Va#{!Va$P!Va$W!Va$h!Va$T!Va~O$V#ZO~OV![O!O#[O~O}#_O!P#_O!Q!XO!R!XO!j#`O!l#`O!m#`O!n#`O!o#`O~O|#cO!`#aOg!^Xh!^Xi!^X!P!^X!R!^X!X!^X!Y!^X!]!^X!j!^X!l!^X!m!^X!n!^X!o!^X#v!^X#w!^X#x!^X#y!^X#z!^X#{!^X$P!^X$W!^X$h!^X$T!^X~O|#cOg!aXh!aXi!aX!P!aX!R!aX!X!aX!Y!aX!]!aX!j!aX!l!aX!m!aX!n!aX!o!aX#v!aX#w!aX#x!aX#y!aX#z!aX#{!aX$P!aX$W!aX$h!aX$T!aX~O!O#gO~Og#iOh#jO$T#iOi!Ta!P!Ta!R!Ta!X!Ta!Y!Ta!]!Ta!j!Ta!l!Ta!m!Ta!n!Ta!o!Ta#v!Ta#w!Ta#x!Ta#y!Ta#z!Ta#{!Ta$P!Ta$W!Ta$h!Ta~O!O#kO~O|#lO~O|#oO~O|#sO~O!PqO!RqO!XqO!YqO!]#wO$h#yO~O$W$OO~O$T$PO~O|$QO$W$SO~O$W$TO~P,tOg#|Xh#|Xi#|X!P#|X!j#|X!l#|X!m#|X!n#|X!o#|X#v#|X#w#|X#x#|X#y#|X#z#|X#{#|X$W#|X~O$T$UO~P<[O!s$WO~P.eO$V$XO~OY#pXZ#pXj#pXk#pXl#pXm#pXn#pXo#pXp#pXq#pXr#pXs#pXt#pX!s#pX#v#pX#w#pX$S#pX$V#pX$X#pX$Y#pX$Z#pX$[#pX$]#pX$^#pX$_#pX$`#pX$a#pX$b#pX$c#pX$d#pX$e#pX$f#pX$g#pX~O`$ZOa$ZO~P=sO^!{O_!{O~P=sO$T$cO~P,tO$W$dO~O!O$fO~Oh$gOg![Xi![X!P![X!R![X!X![X!Y![X!]![X!j![X!l![X!m![X!n![X!o![X#v![X#w![X#x![X#y![X#z![X#{![X$P![X$W![X$h![X$T![X~O$V$hO~OV$iO!O#WO!k$jO!q$kO!s$lO~O|#cO!`$mOg!^ah!^ai!^a!P!^a!R!^a!X!^a!Y!^a!]!^a!j!^a!l!^a!m!^a!n!^a!o!^a#v!^a#w!^a#x!^a#y!^a#z!^a#{!^a$P!^a$W!^a$h!^a$T!^a~O}$oOg!dXh!dXi!dX!P!dX!R!dX!X!dX!Y!dX!]!dX!j!dX!l!dX!m!dX!n!dX!o!dX#v!dX#w!dX#x!dX#y!dX#z!dX#{!dX$P!dX$T!dX$W!dX$h!dX~O$T$pOg!eah!eai!ea!P!ea!R!ea!X!ea!Y!ea!]!ea!j!ea!l!ea!m!ea!n!ea!o!ea#v!ea#w!ea#x!ea#y!ea#z!ea#{!ea$P!ea$W!ea$h!ea~O$T$pOg!bah!bai!ba!P!ba!R!ba!X!ba!Y!ba!]!ba!j!ba!l!ba!m!ba!n!ba!o!ba#v!ba#w!ba#x!ba#y!ba#z!ba#{!ba$P!ba$W!ba$h!ba~Og#iOh#jO$T#iO$W$qO~O}$sO~O$T$tOg!uah!uai!ua!P!ua!R!ua!X!ua!Y!ua!]!ua!j!ua!l!ua!m!ua!n!ua!o!ua#v!ua#w!ua#x!ua#y!ua#z!ua#{!ua$P!ua$W!ua$h!ua~O}!XO!P!XO!Q!XO!R!XOg!{Xh!{Xi!{X!X!{X!Y!{X!]!{X!j!{X!l!{X!m!{X!n!{X!o!{X#v!{X#w!{X#x!{X#y!{X#z!{X#{!{X$P!{X$T!{X$W!{X$h!{X~O$T$uOg!yah!yai!ya!P!ya!R!ya!X!ya!Y!ya!]!ya!j!ya!l!ya!m!ya!n!ya!o!ya#v!ya#w!ya#x!ya#y!ya#z!ya#{!ya$P!ya$W!ya$h!ya~O}!XO!P!XO!Q!XO!R!XOg#OXh#OXi#OX!X#OX!Y#OX!]#OX!j#OX!l#OX!m#OX!n#OX!o#OX#v#OX#w#OX#x#OX#y#OX#z#OX#{#OX$P#OX$T#OX$W#OX$h#OX~O$T$vOg!|ah!|ai!|a!P!|a!R!|a!X!|a!Y!|a!]!|a!j!|a!l!|a!m!|a!n!|a!o!|a#v!|a#w!|a#x!|a#y!|a#z!|a#{!|a$P!|a$W!|a$h!|a~OU$wO~P*eO!k$zO~O!]${O$h#yO~O!PqO!RqO!XqO!YqO!]#wO~O[$}O$W#ca~P!#}O$W%SO~P;]O$W%TO~Oe{Of{Og#Qqh#Qqi#Qq!P#Qq!j#Qq!l#Qq!m#Qq!n#Qq!o#Qq#v#Qq#w#Qq#x#Qq#y#Qq#z#Qq#{#Qq$P#Qq$W#Qq$T#Qq~O$T%WO$W%XO~Oe{Of{Og#mqh#mqi#mq!P#mq!j#mq!l#mq!m#mq!n#mq!o#mq#v#mq#w#mq#x#mq#y#mq#z#mq#{#mq$P#mq$W#mq$T#mq~O$W%YO~P,tO$T%[O~P<[O#u%]O$W%`O~OY#paZ#paj#pak#pal#pam#pan#pao#pap#paq#par#pas#pat#pa!s#pa#v#pa#w#pa$S#pa$X#pa$Y#pa$Z#pa$[#pa$]#pa$^#pa$_#pa$`#pa$a#pa$b#pa$c#pa$d#pa$e#pa$f#pa$g#pa~O$V$XO~P!(WO`%bOa%bO$V#pa~P!(WOg!POi!PO!P!TO!j!TO!l!TO!m!TO!n!TO!o!TO#v!QO#w!QO#x#oq#y#oq#z#oq#{#oq$P#oq$W#oq~Oh#oq~P!*rOg#oqh#oqi#oq~P!*xOh!OO~P!*rO$P#oq$W#oq~P%aOg#oqh#oqi#oq!P#oq!j#oq!l#oq!m#oq!n#oq!o#oq#x#oq#y#oq#z#oq#{#oq~O#v!QO#w!QO$P#oq$W#oq~P!,mO!O%cO~O$W%dO~O!O%fO~O$V%gO~O$T$pOg!eih!eii!ei!P!ei!R!ei!X!ei!Y!ei!]!ei!j!ei!l!ei!m!ei!n!ei!o!ei#v!ei#w!ei#x!ei#y!ei#z!ei#{!ei$P!ei$W!ei$h!ei~O!O%hO~O|#cO~Og#iO$T#iOh!fii!fi!P!fi!R!fi!X!fi!Y!fi!]!fi!j!fi!l!fi!m!fi!n!fi!o!fi#v!fi#w!fi#x!fi#y!fi#z!fi#{!fi$P!fi$W!fi$h!fi~O|%jO!O%jO~O|%oO$j%qO$k%rO$l%sO~O[$}O$W#ci~O$i%uO~O$W#ci~P!#}O!k%xO~O!]${O$W#ci~O$W%zO~P;]O!]${O$W%zO$h#yO~O$W%|O~O|%}O~O$W&OO~P,tO$T&QO$W&RO~O$V$XOY#piZ#pij#pik#pil#pim#pin#pio#pip#piq#pir#pis#pit#pi!s#pi#v#pi#w#pi$S#pi$X#pi$Y#pi$Z#pi$[#pi$]#pi$^#pi$_#pi$`#pi$a#pi$b#pi$c#pi$d#pi$e#pi$f#pi$g#pi~O$T&TO~O$W&UO~O!O&VO~O$V&WO~Og#iOh#jO$T#iO!]#fi$h#fi$W#fi~O!]${O$W#cq~O$W#cq~P!#}O[$}O!]&ZO$W#cq~Oe{Of{Og#Q!Rh#Q!Ri#Q!R!P#Q!R!j#Q!R!l#Q!R!m#Q!R!n#Q!R!o#Q!R#v#Q!R#w#Q!R#x#Q!R#y#Q!R#z#Q!R#{#Q!R$P#Q!R$W#Q!R$T#Q!R~Oe{Of{Og#m!Rh#m!Ri#m!R!P#m!R!j#m!R!l#m!R!m#m!R!n#m!R!o#m!R#v#m!R#w#m!R#x#m!R#y#m!R#z#m!R#{#m!R$P#m!R$W#m!R$T#m!R~O$W&^O~P,tO#u%]O$W&`O~O!O&aO~O$W&bO~O|&cO~O!]${O$W#cy~O[$}O$W#cy~OU$wO~O!]&ZO$W#cy~O$T&fO~O$W&gO~O!]${O$W#c!R~O!O&iO~O$T&jO~O!O&kO~O$W&lO~OP!cOQ!bOR!eOS!dOT!dOW&mOX!jOb!lOc!mOd!nO|!aO$V!hO~O!]&nO$Txa~P+]O!]&nO$TxX~P#hOg&xOi&xO!P&|O!j&|O!l&|O!m&|O!n&|O!o&|O#v&yO#w&yO#x#oq#y#oq#z#oq#{#oq$T#oq~Oh#oq~P!=dOg#oqh#oqi#oq~P!=jOh&wO~P!=dOg&xOh&wOi&xO!P&|O!j&|O!l&|O!m&|O!n&|O!o&|O#v&yO#w&yO#x&zO#y&zO#z&zO#{&{O~O$T#oq~P!?QO#v&yO#w&yO$T#oq~P!,mO\",\n  goto: \"0v$PPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPP$Q%P%h&W&ZPPPPPP&r'U'f't(VPP(f(nP(w(|P(w(w)P)Y(w)b)s)s)|PPPPPP)|P)sP(w(w*V*](w(w*d*g(w*m*p*v+i,O,e,e,e,e,e,e,e,e,e,e,e,e,e,e,e,z-T-h-t.^.a.a.a.d.s+i.v+i/]0R0d0m0pPPPPPPP+i+i+i[WOR|!z$U%[Q$]#OQ$^#PS$_#Q&sQ$`#RQ$a#SQ$b#TQ&}&qQ'O&rQ'P&tQ'Q&uQ'R&vR'S!Vt^O|!V!z#O#P#Q#R#S#T$U%[&q&r&s&t&u&vRxRjQOR|!V!z#O#P#Q#R#S#T$U%[S!sz$PQ#|!t]&p&q&r&s&t&u&vRpPQoP^!gu!h#i#j#w${&nQ#X!YS#p!m$uT#t!n$vQwQQ#x!sQ$|#{Q%Q#|Q%y%PR&o&p[vQ!s#{#|%P&p]!pw#x$|%Q%y&oitQw!s#x#{#|$|%P%Q%y&o&phsQw!s#x#{#|$|%P%Q%y&o&pR!`tkrQtw!s#x#{#|$|%P%Q%y&o&pQ!^rV#]!_#Y$gQ#^!_Q$e#YR%e$gV!ou#w&nR#b!bQ#e!bQ#f!cR$n#bU#d!b!c#bR%i$pU!iu#w&nQ#h!hQ$q#iQ$r#jR%v${_!gu!h#i#j#w${&n_!fu!h#i#j#w${&nQ#n!kR&h&mS#m!k&mR%k$tR#r!mQ#q!mR%l$uR#v!nQ#u!nR%m$vj^O#O#P#Q#R#S#T&q&r&s&t&u&vQyRQ!x|Q#U!VQ$V!zQ%Z$UR&P%[w]OR|!V!z#O#P#Q#R#S#T$U%[&q&r&s&t&u&vwTOR|!V!z#O#P#Q#R#S#T$U%[&q&r&s&t&u&vwSOR|!V!z#O#P#Q#R#S#T$U%[&q&r&s&t&u&vQ!uzQ#}!tR%V$PS#{!s#|W$y#x#z%Q%RQ%t$xQ%{%SR&Y%zQ%P#{Q%t$yQ&[%{R&d&YQ#z!sS$x#x%QQ%O#{Q%R#|S%w$|%PS&X%y%{R&e&[R%p$wR%n$wQ}VQ%U$OQ%Y$TQ&]%|R&^&OR$R!wwVOR|!V!z#O#P#Q#R#S#T$U%[&q&r&s&t&u&vQ#O!OQ#P!PQ#Q!QQ#R!RQ#S!SQ#T!TQ&q&wQ&r&xQ&s&yQ&t&zQ&u&{R&v&|h!|!O!P!Q!R!S!T&w&x&y&z&{&|R$[!}Q$Y!{Q%a$ZR&S%bR%^$XQ%_$XR&_&Q\",\n  nodeNames: \"âš  Json Logfmt Unpack Pattern Regexp Unwrap Ip LabelFormat LineFormat LabelReplace Vector Offset Bool On Ignoring GroupLeft GroupRight Decolorize Drop Keep By Without And Or Unless Sum Avg Count Max Min Stddev Stdvar Bottomk Topk Sort Sort_Desc LineComment LogQL Expr LogExpr Selector Matchers Matcher Identifier Eq String Neq Re Nre PipelineExpr PipelineStage LineFilters LineFilter Filter PipeExact PipeMatch FilterOp OrFilter Pipe LogfmtParser LogfmtParserFlags ParserFlag LabelParser JsonExpressionParser LabelExtractionExpressionList LabelExtractionExpression LogfmtExpressionParser LabelFilter IpLabelFilter UnitFilter DurationFilter Gtr Duration Gte Lss Lte Eql BytesFilter Bytes NumberFilter Number LineFormatExpr LabelFormatExpr LabelsFormat LabelFormatMatcher DecolorizeExpr DropLabelsExpr DropLabels DropLabel KeepLabelsExpr KeepLabels KeepLabel MetricExpr RangeAggregationExpr RangeOp CountOverTime Rate RateCounter BytesOverTime BytesRate AvgOverTime SumOverTime MinOverTime MaxOverTime StddevOverTime StdvarOverTime QuantileOverTime FirstOverTime LastOverTime AbsentOverTime LogRangeExpr Range OffsetExpr UnwrapExpr ConvOp BytesConv DurationConv DurationSecondsConv Grouping Labels VectorAggregationExpr VectorOp BinOpExpr BinOpModifier OnOrIgnoringModifier GroupingLabels GroupingLabelList GroupingLabel LabelName Add Sub Mul Div Mod Pow LiteralExpr LabelReplaceExpr VectorExpr\",\n  maxTerm: 166,\n  skippedNodes: [0,37],\n  repeatNodeCount: 0,\n  tokenData: \"5b~RvX^#ipq#iqr$^rs$qst%cuv%nxy%syz%xz{%}{|&S|}&X}!O&^!O!P(l!P!Q)l!Q!R)q!R![+X![!]2X!^!_2m!_!`2z!`!a3a!c!}3n!}#O4U#P#Q4Z#Q#R4`#R#S3n#S#T4e#T#o3n#o#p4q#p#q4v#q#r5]#y#z#i$f$g#i#BY#BZ#i$IS$I_#i$I|$JO#i$JT$JU#i$KV$KW#i&FU&FV#i~#nY$R~X^#ipq#i#y#z#i$f$g#i#BY#BZ#i$IS$I_#i$I|$JO#i$JT$JU#i$KV$KW#i&FU&FV#i~$aQ!_!`$g#r#s$l~$lO!P~~$qO!R~~$tUOY$qZr$qrs%Ws#O$q#O#P%]#P~$q~%]O!O~~%`PO~$q~%hQu~OY%cZ~%c~%sO#z~~%xO$V~~%}O$W~~&SO#x~~&XO#v~~&^O$T~~&cP#w~}!O&f~&iQ#_#`&o#g#h'|~&rP#X#Y&u~&xP#X#Y&{~'OP#d#e'R~'UP}!O'X~'[P#X#Y'_~'bP#a#b'e~'hP#d#e'k~'nP#h#i'q~'tP#m#n'w~'|O!`~~(PP#h#i(S~(VP#f#g(Y~(]P#]#^(`~(cP#V#W(f~(iP#h#i'w~(oP!Q![(r~(wR!s~!Q![(r!g!h)Q#X#Y)Q~)TR{|)^}!O)^!Q![)d~)aP!Q![)d~)iP!s~!Q![)d~)qO#y~~)ve!s~!O!P(r!Q![+X!g!h,l!i!j-Z!m!n-Z!o!p-Z!r!s-Z!v!w-Z#U#V-O#W#X-d#X#Y/f#Z#[/x#[#]-{#_#`/x#a#b0R#d#e/x#g#h/T#h#i/x#k#l0d#l#m1m#m#n1O~+^d!s~!O!P(r!Q![+X!g!h,l!i!j-Z!m!n-Z!o!p-Z!r!s-Z!v!w-Z#U#V-O#W#X-d#X#Y/f#Z#[/x#[#]-{#_#`/x#a#b0R#d#e/x#g#h/T#h#i/x#k#l0d#m#n1O~,oT{|)^}!O)^!Q![)d!d!e-O#]#^-T~-TO!q~~-WP#U#V-O~-^Q!d!e-O#]#^-T~-iP!k~!Q![-l~-oS!Q![-l#[#]-{#a#b.a#g#h/T~.QP!k~!Q![.T~.WR!Q![.T#a#b.a#g#h/T~.fQ!k~!Q![.l#g#h/O~.oR!Q![.l#a#b.x#g#h/T~.{P#g#h/O~/TO!k~~/YP!k~!Q![/]~/`Q!Q![/]#a#b.x~/iT{|)^}!O)^!Q![)d#U#V-O#]#^-T~/{Q#U#V-O#]#^-T~0WS!k~!Q![.l#U#V-O#]#^-T#g#h/O~0iP!k~!Q![0l~0oT!Q![0l#W#X-d#[#]-{#a#b.a#g#h/T~1TP!k~!Q![1W~1ZU!Q![1W#W#X-d#[#]-{#a#b.a#g#h/T#k#l0d~1pR!Q![1y!c!i1y#T#Z1y~2OR!s~!Q![1y!c!i1y#T#Z1yP2^T|P!Q![2X![!]2X!c!}2X#R#S2X#T#o2X~2rP!m~!_!`2u~2zO!n~~3PQ}~!_!`3V#r#s3[~3[O!o~~3aO!Q~~3fP!j~!_!`3i~3nO!l~R3uT|P#uQ!Q![3n![!]2X!c!}3n#R#S3n#T#o3n~4ZO$h~~4`O$i~~4eO#{~~4hRO#S4e#S#T%W#T~4e~4vO$S~~4{Q!]~!_!`5R#r#s5W~5WO!X~~5]O!Y~~5bO$U~\",\n  tokenizers: [0, 1],\n  topRules: {\"LogQL\":[0,38]},\n  specialized: [{term: 44, get: (value, stack) => (specializeIdentifier(value) << 1)},{term: 44, get: (value, stack) => (extendIdentifier(value) << 1) | 1},{term: 44, get: value => spec_Identifier[value] || -1}],\n  tokenPrec: 0\n});\n// This file was generated by lezer-generator. You probably shouldn't edit it.\nconst Json = 1,\n  Logfmt = 2,\n  Unpack = 3,\n  Pattern = 4,\n  Regexp = 5,\n  Unwrap = 6,\n  Ip = 7,\n  LabelFormat = 8,\n  LineFormat = 9,\n  LabelReplace = 10,\n  Vector = 11,\n  Offset = 12,\n  Bool = 13,\n  On = 14,\n  Ignoring = 15,\n  GroupLeft = 16,\n  GroupRight = 17,\n  Decolorize = 18,\n  Drop = 19,\n  Keep = 20,\n  By = 21,\n  Without = 22,\n  And = 23,\n  Or = 24,\n  Unless = 25,\n  Sum = 26,\n  Avg = 27,\n  Count = 28,\n  Max = 29,\n  Min = 30,\n  Stddev = 31,\n  Stdvar = 32,\n  Bottomk = 33,\n  Topk = 34,\n  Sort = 35,\n  Sort_Desc = 36,\n  LineComment = 37,\n  LogQL = 38,\n  Expr = 39,\n  LogExpr = 40,\n  Selector = 41,\n  Matchers = 42,\n  Matcher = 43,\n  Identifier = 44,\n  Eq = 45,\n  String = 46,\n  Neq = 47,\n  Re = 48,\n  Nre = 49,\n  PipelineExpr = 50,\n  PipelineStage = 51,\n  LineFilters = 52,\n  LineFilter = 53,\n  Filter = 54,\n  PipeExact = 55,\n  PipeMatch = 56,\n  FilterOp = 57,\n  OrFilter = 58,\n  Pipe = 59,\n  LogfmtParser = 60,\n  LogfmtParserFlags = 61,\n  ParserFlag = 62,\n  LabelParser = 63,\n  JsonExpressionParser = 64,\n  LabelExtractionExpressionList = 65,\n  LabelExtractionExpression = 66,\n  LogfmtExpressionParser = 67,\n  LabelFilter = 68,\n  IpLabelFilter = 69,\n  UnitFilter = 70,\n  DurationFilter = 71,\n  Gtr = 72,\n  Duration = 73,\n  Gte = 74,\n  Lss = 75,\n  Lte = 76,\n  Eql = 77,\n  BytesFilter = 78,\n  Bytes = 79,\n  NumberFilter = 80,\n  Number = 81,\n  LineFormatExpr = 82,\n  LabelFormatExpr = 83,\n  LabelsFormat = 84,\n  LabelFormatMatcher = 85,\n  DecolorizeExpr = 86,\n  DropLabelsExpr = 87,\n  DropLabels = 88,\n  DropLabel = 89,\n  KeepLabelsExpr = 90,\n  KeepLabels = 91,\n  KeepLabel = 92,\n  MetricExpr = 93,\n  RangeAggregationExpr = 94,\n  RangeOp = 95,\n  CountOverTime = 96,\n  Rate = 97,\n  RateCounter = 98,\n  BytesOverTime = 99,\n  BytesRate = 100,\n  AvgOverTime = 101,\n  SumOverTime = 102,\n  MinOverTime = 103,\n  MaxOverTime = 104,\n  StddevOverTime = 105,\n  StdvarOverTime = 106,\n  QuantileOverTime = 107,\n  FirstOverTime = 108,\n  LastOverTime = 109,\n  AbsentOverTime = 110,\n  LogRangeExpr = 111,\n  Range = 112,\n  OffsetExpr = 113,\n  UnwrapExpr = 114,\n  ConvOp = 115,\n  BytesConv = 116,\n  DurationConv = 117,\n  DurationSecondsConv = 118,\n  Grouping = 119,\n  Labels = 120,\n  VectorAggregationExpr = 121,\n  VectorOp = 122,\n  BinOpExpr = 123,\n  BinOpModifier = 124,\n  OnOrIgnoringModifier = 125,\n  GroupingLabels = 126,\n  GroupingLabelList = 127,\n  GroupingLabel = 128,\n  LabelName = 129,\n  Add = 130,\n  Sub = 131,\n  Mul = 132,\n  Div = 133,\n  Mod = 134,\n  Pow = 135,\n  LiteralExpr = 136,\n  LabelReplaceExpr = 137,\n  VectorExpr = 138;\n\nfunction getNodeFromQuery(query, nodeType) {\n  const nodes = [];\n  const tree = parser.parse(query);\n  tree.iterate({\n    enter: (node) => {\n      if (nodeType === undefined || nodeType === node.type.id) {\n        nodes.push(node.node);\n      }\n    },\n  });\n  return nodes[0];\n}\n\nfunction isLogsQuery(query) {\n  if (getNodeFromQuery(query, MetricExpr$1)) {\n    return false;\n  }\n  return true;\n}\n\nfunction indent(level) {\n  return '  '.repeat(level);\n}\n\nfunction indentMultiline(block, level) {\n  const lines = block.split('\\n');\n  return lines.map((line) => indent(level) + line).join('\\n');\n}\n\nfunction trimMultiline(block) {\n  const lines = block.split('\\n');\n  return lines.map((line) => line.trimEnd()).join('\\n');\n}\n\nfunction needsBrackets(node, queryType) {\n  const childNodeIsSame = node.firstChild?.type.id === queryType;\n  let addBrackets = false;\n\n  if (node.firstChild && childNodeIsSame) {\n    addBrackets = true;\n    node = node.firstChild;\n  }\n\n  return { addBrackets, newNode: node };\n}\n\nfunction iterateNode(node, lookingFor) {\n  const nodes = [];\n  let child = node.firstChild;\n\n  while (child) {\n    if (lookingFor.includes(child.type.id)) {\n      nodes.push(child);\n    }\n\n    nodes.push(...iterateNode(child, lookingFor));\n    child = child.nextSibling;\n  }\n\n  return nodes;\n}\n\nfunction buildResponse(pipelineType, lastPipelineType, formattedNode) {\n  if (lastPipelineType === pipelineType) {\n    return ` ${formattedNode}`;\n  }\n\n  return `\\n${indent(1)}${formattedNode}`;\n}\n\nfunction trimEnd(input, charactersToTrim) {\n  let endIndex = input.length - 1;\n  while (endIndex >= 0 && charactersToTrim.includes(input[endIndex])) {\n    endIndex--;\n  }\n  return input.substring(0, endIndex + 1);\n}\n\nconst formatLogExpr = (node, query) => {\n  const { addBrackets, newNode } = needsBrackets(node, LogExpr);\n  node = newNode;\n\n  const tree = parser.parse(query.substring(node.from, node.to));\n  let formatted = '';\n\n  tree.iterate({\n    enter: (ref) => {\n      const node = ref.node;\n\n      switch (node.type.id) {\n        case Selector:\n          formatted += formatSelector(node, query);\n          break;\n\n        case PipelineExpr:\n          node.parent?.type.id !== PipelineExpr && (formatted += formatPipelineExpr(node, query));\n          break;\n      }\n    },\n  });\n\n  return addBrackets ? '(' + formatted + ')' : formatted;\n};\n\nfunction formatSelector(node, query) {\n  const selector = query.substring(node.from, node.to);\n  const subtree = parser.parse(selector);\n  const labelNodes = [];\n  let response = '';\n\n  subtree.iterate({\n    enter: (ref) => {\n      const node = ref.node;\n      if (node.type.id === Matcher) {\n        labelNodes.push(node);\n      }\n    },\n  });\n\n  labelNodes.sort((a, b) => {\n    const labelNodeA = a.getChild(Identifier);\n    const labelNodeB = b.getChild(Identifier);\n\n    const labelValueA = labelNodeA && query.substring(labelNodeA.from, labelNodeA.to);\n    const labelValueB = labelNodeB && query.substring(labelNodeB.from, labelNodeB.to);\n\n    if (!labelValueA || !labelValueB) {\n      return 0;\n    }\n\n    if (labelValueA < labelValueB) {\n      return -1;\n    }\n\n    if (labelValueA > labelValueB) {\n      return 1;\n    }\n\n    return 0;\n  });\n\n  labelNodes.forEach((node) => {\n    const labelNode = node.getChild(Identifier);\n    const operatorNode = labelNode ? labelNode.nextSibling : null;\n    const valueNode = node.getChild(String);\n\n    const label = labelNode ? query.substring(labelNode.from, labelNode.to) : null;\n    const operator = operatorNode ? query.substring(operatorNode.from, operatorNode.to) : null;\n    const value = valueNode ? query.substring(valueNode.from, valueNode.to) : null;\n\n    response += `${label}${operator}${value}, `;\n  });\n\n  return '{' + trimEnd(response, ', ') + '}';\n}\n\nfunction formatPipelineExpr(node, query) {\n  const pipelineExprNodes = [\n    LineFilter,\n    LabelParser,\n    LogfmtParser,\n    LabelFilter,\n    JsonExpressionParser,\n    LineFormatExpr,\n    LabelFormatExpr,\n    DecolorizeExpr,\n  ];\n  let lastPipelineType;\n  let response = '';\n\n  iterateNode(node, pipelineExprNodes).forEach((node) => {\n    switch (node.type.id) {\n      case LineFilter:\n        response += buildResponse(LineFilter, lastPipelineType, formatLineFilter(node, query));\n        lastPipelineType = LineFilter;\n        break;\n\n      case LabelParser:\n        response += buildResponse(LabelParser, lastPipelineType, formatLabelParser(node, query));\n        lastPipelineType = LabelParser;\n        break;\n\n      case LogfmtParser:\n        response += buildResponse(LogfmtParser, lastPipelineType, formatLabelParser(node, query));\n        lastPipelineType = LogfmtParser;\n        break;\n\n      case JsonExpressionParser:\n        response += buildResponse(JsonExpressionParser, lastPipelineType, formatJsonExpressionParser(node, query));\n        lastPipelineType = JsonExpressionParser;\n        break;\n\n      case LabelFilter:\n        response += buildResponse(LabelFilter, lastPipelineType, formatLabelFilter(node, query));\n        lastPipelineType = LabelFilter;\n        break;\n\n      case LineFormatExpr:\n        response += buildResponse(LineFormatExpr, lastPipelineType, formatLineFormatExpr(node, query));\n        lastPipelineType = LineFormatExpr;\n        break;\n\n      case LabelFormatExpr:\n        response += buildResponse(LabelFormatExpr, lastPipelineType, formatLabelFormatExpr(node, query));\n        lastPipelineType = LabelFormatExpr;\n        break;\n\n      case DecolorizeExpr:\n        response += buildResponse(DecolorizeExpr, lastPipelineType, formatDecolorizeExpr());\n        lastPipelineType = DecolorizeExpr;\n        break;\n    }\n  });\n\n  return response;\n}\n\nfunction formatLineFilter(node, query) {\n  const filterNode = node.getChild(Filter);\n  const filterOperationNode = node.getChild(FilterOp);\n  const stringNode = node.getChild(String);\n\n  const filter = filterNode && query.substring(filterNode.from, filterNode.to);\n  const string = stringNode && query.substring(stringNode.from, stringNode.to);\n\n  if (filterOperationNode) {\n    return `${filter} ip(${string})`;\n  }\n  return `${filter} ${string}`;\n}\n\nfunction formatLabelParser(node, query) {\n  const hasString = node.getChild(String);\n\n  if (hasString) {\n    const parserNode = node.getChild(Regexp) || node.getChild(Pattern);\n    const stringNode = node.getChild(String);\n\n    const parser = parserNode && query.substring(parserNode.from, parserNode.to);\n    const string = stringNode && query.substring(stringNode.from, stringNode.to);\n\n    return `| ${parser}${string}`;\n  }\n\n  const labelParser = query.substring(node.from, node.to);\n  return `| ${labelParser}`;\n}\n\nfunction formatJsonExpressionParser(node, query) {\n  const jsonExpressionNodes = iterateNode(node, [LabelExtractionExpression]);\n  let response = '';\n\n  jsonExpressionNodes.forEach((node) => {\n    const identifierNode = node.getChild(Identifier);\n    const valueNode = node.getChild(String);\n\n    const identifier = identifierNode && query.substring(identifierNode.from, identifierNode.to);\n    const value = valueNode && query.substring(valueNode.from, valueNode.to);\n\n    response += `${identifier}=${value}, `;\n  });\n\n  return `| json ${trimEnd(response, ', ')}`;\n}\n\nfunction formatLabelFilter(node, query) {\n  const selectedFilter =\n    node.getChild(Matcher) ||\n    node.getChild(IpLabelFilter) ||\n    node.getChild(NumberFilter) ||\n    node.getChild(UnitFilter)?.getChild(DurationFilter) ||\n    node.getChild(UnitFilter)?.getChild(BytesFilter);\n\n  if (!selectedFilter) {\n    return '';\n  }\n\n  const selectedFilterType = selectedFilter.type.id;\n\n  const identifierNode = selectedFilter.getChild(Identifier);\n  const operatorNode = identifierNode && identifierNode.nextSibling;\n  let valueNode;\n\n  if (selectedFilterType === DurationFilter) {\n    valueNode = selectedFilter.getChild(Duration);\n  } else if (selectedFilterType === BytesFilter) {\n    valueNode = selectedFilter.getChild(Bytes);\n  } else if (selectedFilterType === NumberFilter) {\n    valueNode = selectedFilter.getChild(Number);\n  } else {\n    valueNode = selectedFilter.getChild(String);\n  }\n\n  const identifier = identifierNode && query.substring(identifierNode.from, identifierNode.to);\n  const operator = operatorNode && query.substring(operatorNode.from, operatorNode.to);\n  const value = valueNode && query.substring(valueNode.from, valueNode.to);\n\n  if (selectedFilterType === IpLabelFilter) {\n    return `| ${identifier}${operator}ip(${value})`;\n  }\n\n  return `| ${identifier}${operator}${value}`;\n}\n\nfunction formatLineFormatExpr(node, query) {\n  const stringNode = node.getChild(String);\n  const string = stringNode && query.substring(stringNode.from, stringNode.to);\n  return `| line_format ${string}`;\n}\n\nfunction formatLabelFormatExpr(node, query) {\n  const labelFormatMatcherNodes = iterateNode(node, [LabelFormatMatcher]);\n  let response = '| label_format ';\n\n  labelFormatMatcherNodes.forEach((labelFormatMatcherNode) => {\n    let identifierNode;\n    let valueNode;\n\n    if (labelFormatMatcherNode.getChildren(Identifier).length === 2) {\n      [identifierNode, valueNode] = labelFormatMatcherNode.getChildren(Identifier);\n    } else {\n      identifierNode = labelFormatMatcherNode.getChild(Identifier);\n      valueNode = labelFormatMatcherNode.getChild(String);\n    }\n\n    const identifier = identifierNode && query.substring(identifierNode.from, identifierNode.to);\n    const value = valueNode && query.substring(valueNode.from, valueNode.to);\n\n    response += `${identifier}=${value}, `;\n  });\n\n  return trimEnd(response, ', ');\n}\n\nfunction formatDecolorizeExpr() {\n  return `| decolorize`;\n}\n\nconst formatMetricExpr = (node, query) => {\n  const { addBrackets, newNode } = needsBrackets(node, MetricExpr);\n  node = newNode;\n  let formatted = '';\n\n  const childNode = node.firstChild;\n  switch (childNode && childNode.type.id) {\n    case RangeAggregationExpr:\n      formatted = formatRangeAggregationExpr(node, query);\n      break;\n\n    case VectorAggregationExpr:\n      formatted = formatVectorAggregationExpr(node, query);\n      break;\n\n    case BinOpExpr:\n      formatted = formatBinOpExpr(node, query);\n      break;\n\n    case LiteralExpr:\n      formatted = formatLiteralExpr(node, query);\n      break;\n\n    case LabelReplaceExpr:\n      formatted = formatLabelReplaceExpr(node, query);\n      break;\n\n    case VectorExpr:\n      formatted = formatVectorExpr(node, query);\n      break;\n  }\n\n  return addBrackets ? '(' + formatted + ')' : formatted;\n};\n\nfunction formatRangeAggregationExpr(node, query) {\n  let response = '';\n\n  iterateNode(node, [RangeOp, Number, LogRangeExpr, Grouping]).forEach((node) => {\n    if (node.parent?.type.id !== RangeAggregationExpr) {\n      return;\n    }\n\n    switch (node.type.id) {\n      case RangeOp:\n        response += `${query.substring(node.from, node.to)}(\\n`;\n        break;\n\n      case Number:\n        response += `${indent(1) + query.substring(node.from, node.to)},\\n`;\n        break;\n\n      case LogRangeExpr:\n        response += formatLogRangeExpr(node, query);\n        break;\n\n      case Grouping:\n        response += formatGrouping(node, query);\n        break;\n    }\n  });\n\n  return response;\n}\n\nfunction formatLogRangeExpr(node, query) {\n  const nodes = [];\n  let selector = '';\n  let pipeline = '';\n  let range = '';\n  let offset = '';\n  let unwrap = '';\n\n  iterateNode(node, [Selector, Range, OffsetExpr, UnwrapExpr, PipelineExpr]).forEach((node) => {\n    if (node.parent?.type.id !== LogRangeExpr) {\n      return;\n    }\n\n    nodes.push(node);\n\n    switch (node.type.id) {\n      case Selector: {\n        let logExpr = query.substring(node.from, node.to);\n        selector += formatSelector({ ...node, from: 0, to: logExpr.length }, logExpr);\n        break;\n      }\n\n      case PipelineExpr:\n        pipeline += formatPipelineExpr(node, query);\n        break;\n\n      case Range:\n        range += query.substring(node.from, node.to);\n        break;\n\n      case OffsetExpr: {\n        const durationNode = node.getChild(Duration);\n        offset += ` offset ${durationNode ? query.substring(durationNode.from, durationNode.to) : ''}`;\n        break;\n      }\n\n      case UnwrapExpr:\n        iterateNode(node, [Identifier, ConvOp, LabelFilter]).forEach((node, _, arr) => {\n          switch (node.type.id) {\n            case Identifier: {\n              if (node.parent?.type.id !== UnwrapExpr) {\n                return;\n              }\n\n              const hasConvOp = arr.find((node) => node.type.id === ConvOp);\n\n              if (hasConvOp) {\n                return;\n              }\n\n              unwrap += `| unwrap ${query.substring(node.from, node.to)} `;\n              return;\n            }\n\n            case ConvOp: {\n              const identifierNode = arr.find((node) => node.type.id === Identifier);\n              const identifier = identifierNode ? query.substring(identifierNode.from, identifierNode.to) : '';\n              unwrap += `| unwrap ${query.substring(node.from, node.to)}(${identifier}) `;\n              return;\n            }\n\n            case LabelFilter:\n              unwrap += formatLabelFilter(node, query);\n              return;\n          }\n        });\n        break;\n    }\n  });\n\n  let response = '';\n  nodes.forEach((node, index, array) => {\n    const previousNode = array[index - 1];\n\n    if (node.type.id === Selector) {\n      response += indent(1) + selector;\n    }\n\n    if (node.type.id === PipelineExpr) {\n      response += indentMultiline(pipeline, 1);\n    }\n\n    if (node.type.id === Range) {\n      response += '\\n' + indent(1) + range;\n    }\n\n    if (node.type.id === OffsetExpr) {\n      response += offset;\n    }\n\n    if (node.type.id === UnwrapExpr) {\n      if (previousNode?.type.id !== OffsetExpr && previousNode?.type.id !== Range) {\n        response += '\\n' + indent(1) + unwrap;\n      } else {\n        response += ' ' + unwrap;\n      }\n    }\n  });\n\n  return (response += '\\n)');\n}\n\nfunction formatGrouping(node, query) {\n  let response = '';\n\n  const labels = iterateNode(node, [Identifier]).map((node) => {\n    return query.substring(node.from, node.to);\n  });\n\n  iterateNode(node, [By, Without]).forEach((node) => {\n    if (node.parent?.type.id !== Grouping) {\n      return;\n    }\n\n    switch (node.type.id) {\n      case By:\n        response = ` by (${labels.join(', ')}) `;\n        break;\n\n      case Without:\n        response = ` without (${labels.join(', ')}) `;\n        break;\n    }\n  });\n\n  return response;\n}\n\nfunction formatVectorAggregationExpr(node, query) {\n  let response = '';\n\n  iterateNode(node, [VectorOp, Number, MetricExpr, Grouping]).forEach((node, _, arr) => {\n    if (node.parent?.type.id !== VectorAggregationExpr) {\n      return;\n    }\n\n    switch (node.type.id) {\n      case VectorOp:\n        response += `${query.substring(node.from, node.to)}`;\n        break;\n\n      case Number:\n        response += `(\\n`;\n        response += `${indent(1) + query.substring(node.from, node.to)},\\n`;\n        break;\n\n      case MetricExpr: {\n        const hasNumber = arr.find((node) => node.type.id === Number && node.parent?.type.id === VectorAggregationExpr);\n        response += hasNumber ? '' : '(\\n';\n\n        const metricExpr = query.substring(node.from, node.to);\n        const metricNode = getNodeFromQuery(metricExpr, MetricExpr);\n        response += indentMultiline(formatMetricExpr(metricNode, metricExpr), 1);\n        response += '\\n)';\n        break;\n      }\n\n      case Grouping:\n        response += formatGrouping(node, query);\n        break;\n    }\n  });\n\n  return response;\n}\n\nfunction formatBinOpExpr(node, query) {\n  let operator;\n\n  const [leftExpr, rightExpr] = iterateNode(node, [Expr]).map((node, idx) => {\n    if (idx === 0) {\n      operator = query.substring(node.nextSibling?.from ?? 0, node.nextSibling?.to);\n    }\n\n    const expr = query.substring(node.from, node.to);\n    let expressionNode;\n\n    if (isLogsQuery(expr)) {\n      expressionNode = getNodeFromQuery(expr, LogExpr);\n      return formatLogExpr(expressionNode, expr);\n    } else {\n      expressionNode = getNodeFromQuery(expr, MetricExpr);\n      return formatMetricExpr(expressionNode, expr);\n    }\n  });\n\n  return leftExpr + '\\n' + operator + '\\n' + rightExpr;\n}\n\nfunction formatLiteralExpr(node, query) {\n  node = node.getChild(LiteralExpr) ?? node;\n  const addNode = node.getChild(Add);\n  const subNode = node.getChild(Sub);\n  const numberNode = node.getChild(Number);\n\n  if (!numberNode) {\n    return '';\n  }\n\n  if (addNode) {\n    return `+${query.substring(numberNode.from, numberNode.to)}`;\n  }\n\n  if (subNode) {\n    return `-${query.substring(numberNode.from, numberNode.to)}`;\n  }\n\n  return query.substring(numberNode.from, numberNode.to);\n}\n\nfunction formatLabelReplaceExpr(node, query) {\n  let response = 'label_replace(\\n';\n\n  iterateNode(node, [MetricExpr, String]).forEach((node) => {\n    if (node.parent?.type.id !== LabelReplaceExpr) {\n      return;\n    }\n\n    if (node.type.id === MetricExpr) {\n      const metricExpr = query.substring(node.from, node.to);\n      const metricNode = getNodeFromQuery(metricExpr, MetricExpr);\n      response += indentMultiline(formatMetricExpr(metricNode, metricExpr), 1) + ',\\n';\n    } else {\n      response += indent(1) + query.substring(node.from, node.to) + ',\\n';\n    }\n  });\n\n  return trimEnd(response, ',\\n') + '\\n)';\n}\n\nfunction formatVectorExpr(node, query) {\n  node = node.getChild(VectorExpr) ?? node;\n  const numberNode = node.getChild(Number);\n\n  if (!numberNode) {\n    return '';\n  }\n\n  return `vector(${query.substring(numberNode.from, numberNode.to)})`;\n}\n\n/**\n * @experimental This feature is subject to change or removal in future versions.\n */\nconst formatLokiQuery = (query) => {\n  const tree = parser.parse(query);\n  let formatted = '';\n\n  tree.iterate({\n    enter: (ref) => {\n      const node = ref.node;\n\n      if (node.parent?.type.id !== Expr || node.parent?.parent?.type.id === BinOpExpr) {\n        return;\n      }\n\n      switch (node.type.id) {\n        case MetricExpr:\n          formatted = formatMetricExpr(node, query);\n          return false;\n\n        case LogExpr:\n          formatted = formatLogExpr(node, query);\n          return false;\n      }\n    },\n  });\n\n  return trimMultiline(formatted);\n};\n\nexport { AbsentOverTime, Add, And, Avg, AvgOverTime, BinOpExpr, BinOpModifier, Bool, Bottomk, By, Bytes, BytesConv, BytesFilter, BytesOverTime, BytesRate, ConvOp, Count, CountOverTime, Decolorize, DecolorizeExpr, Div, Drop, DropLabel, DropLabels, DropLabelsExpr, Duration, DurationConv, DurationFilter, DurationSecondsConv, Eq, Eql, Expr, Filter, FilterOp, FirstOverTime, GroupLeft, GroupRight, Grouping, GroupingLabel, GroupingLabelList, GroupingLabels, Gte, Gtr, Identifier, Ignoring, Ip, IpLabelFilter, Json, JsonExpressionParser, Keep, KeepLabel, KeepLabels, KeepLabelsExpr, LabelExtractionExpression, LabelExtractionExpressionList, LabelFilter, LabelFormat, LabelFormatExpr, LabelFormatMatcher, LabelName, LabelParser, LabelReplace, LabelReplaceExpr, Labels, LabelsFormat, LastOverTime, LineComment, LineFilter, LineFilters, LineFormat, LineFormatExpr, LiteralExpr, LogExpr, LogQL, LogRangeExpr, Logfmt, LogfmtExpressionParser, LogfmtParser, LogfmtParserFlags, Lss, Lte, Matcher, Matchers, Max, MaxOverTime, MetricExpr, Min, MinOverTime, Mod, Mul, Neq, Nre, Number, NumberFilter, Offset, OffsetExpr, On, OnOrIgnoringModifier, Or, OrFilter, ParserFlag, Pattern, Pipe, PipeExact, PipeMatch, PipelineExpr, PipelineStage, Pow, QuantileOverTime, Range, RangeAggregationExpr, RangeOp, Rate, RateCounter, Re, Regexp, Selector, Sort, Sort_Desc, Stddev, StddevOverTime, Stdvar, StdvarOverTime, String, Sub, Sum, SumOverTime, Topk, UnitFilter, Unless, Unpack, Unwrap, UnwrapExpr, Vector, VectorAggregationExpr, VectorExpr, VectorOp, Without, formatLokiQuery, parser };\n"],"names":["exports","wordPattern","comments","lineComment","brackets","autoClosingPairs","open","close","surroundingPairs","folding","vector_matching","vectorMatchingRegex","concat","reduce","prev","curr","keywords","ignoreCase","defaultToken","tokenPostfix","operators","vectorMatching","symbols","escapes","digits","octaldigits","binarydigits","hexdigits","integersuffix","floatsuffix","tokenizer","root","cases","include","string_double","token","string_single","string_backtick","clauses","whitespace","value","ref","useRef","current","keywordTokens","json","logfmt","unpack","pattern","regexp","ip","label_format","line_format","label_replace","vector","offset","bool","on","ignoring","group_left","group_right","unwrap","decolorize","drop","keep","contextualKeywordTokens","by","without","and","or","unless","sum","avg","count","max","min","stddev","stdvar","bottomk","topk","sort","sort_desc","spec_Identifier","__proto__","count_over_time","rate","rate_counter","bytes_over_time","bytes_rate","avg_over_time","sum_over_time","min_over_time","max_over_time","stddev_over_time","stdvar_over_time","quantile_over_time","first_over_time","last_over_time","absent_over_time","bytes","duration","duration_seconds","parser","deserialize","version","states","stateData","goto","nodeNames","maxTerm","skippedNodes","repeatNodeCount","tokenData","tokenizers","topRules","specialized","term","get","stack","toLowerCase","specializeIdentifier","extendIdentifier","tokenPrec"],"sourceRoot":""}